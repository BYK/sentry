# Generated by Django 5.0.2 on 2024-03-07 19:31

import logging

from django.conf import settings
from django.db import migrations
from django.db.models import F, Q

from sentry import roles
from sentry.new_migrations.migrations import CheckedMigration
from sentry.services.hybrid_cloud.user.service import UserService
from sentry.utils import redis
from sentry.utils.email.message_builder import MessageBuilder
from sentry.utils.query import RangeQuerySetWrapperWithProgressBarApprox

logger = logging.getLogger(__name__)

FIRST_SEEN_EVENT_CONDITION = [
    {"id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition"}
]
DEFAULT_ALERT_LABEL = "Send a notification for new issues"
HIGH_PRIORITY_CONDITION = [
    {"id": "sentry.rules.conditions.high_priority_issue.HighPriorityIssueCondition"}
]
NEW_DEFAULT_ALERT_LABEL = "Send a notification for high priority issues"
DELAY_THRESHOLD = 2
BATCH_SIZE = 100
REDIS_KEY = "priority_alerts_migration.last_processed_id"


def get_members_with_org_roles(
    organization,
    roles,
):
    return organization.member_set.filter(
        role__in=roles, user_id__isnull=False, user_is_active=True
    )


def get_owners(organization):
    owners = get_members_with_org_roles(organization, roles=[roles.get_top_dog().id]).values_list(
        "user_id", flat=True
    )

    return UserService.get_many(filter={"user_ids": list(owners)})


def update_default_alert_rule(apps, schema_editor):
    Organization = apps.get_model("sentry", "Organization")
    Project = apps.get_model("sentry", "Project")
    AlertRule = apps.get_model("sentry", "AlertRule")

    batch = []
    alerts_per_org = {}

    early_adopter_flag = Organization.flags.early_adopter
    redis_client = redis.redis_clusters.get(settings.SENTRY_MONITORS_REDIS_CLUSTER)
    last_processed_id = int(redis_client.get(REDIS_KEY) or 0)
    for organization in RangeQuerySetWrapperWithProgressBarApprox(
        Organization.objects.filter(
            id__gt=last_processed_id,
            flags=F("flags").bitor(early_adopter_flag),
        ),
    ):
        owners_emails = [owner.email for owner in get_owners(organization)]
        data = {
            "emails": owners_emails,
            "alerts": {},
        }

        platform_query = Q(
            Q(platform__startswith="python") | Q(platform__startswith="javascript"),
            organization=organization,
        )
        for project_id, project_slug, project_creation in RangeQuerySetWrapperWithProgressBarApprox(
            Project.objects.filter(platform_query).values("id", "slug", "date_added", flat=True),
            result_value_getter=lambda item: item[0],
        ):
            for rule in AlertRule.objects.filter(project_id=project_id, label=DEFAULT_ALERT_LABEL):
                conditions = rule.data.get("conditions", [{}])
                if not conditions or conditions != FIRST_SEEN_EVENT_CONDITION:
                    continue

                if abs((project_creation - rule.date_added).total_seconds()) > DELAY_THRESHOLD:
                    continue

                rule.data["conditions"] = HIGH_PRIORITY_CONDITION
                rule.label = NEW_DEFAULT_ALERT_LABEL
                batch.append(rule)

                rule_text = f"{organization.slug}/{project_slug}: {NEW_DEFAULT_ALERT_LABEL}"
                rule_url = (
                    f"{organization.slug}.sentry.io/alerts/rules/{project_slug}/{rule.id}/details/"
                )
                data["alerts"].update({rule_text: rule_url})

        alerts_per_org[organization.id] = data

        if len(batch) >= BATCH_SIZE:
            logger.info(
                "Processing batch for group priority backfill with %s items",
                BATCH_SIZE,
                extra={"organization_id": organization.id},
            )
            AlertRule.objects.bulk_update(batch, ["label", "data"])
            msg = MessageBuilder(
                subject="Your feedback requested: new priority alerts",
                from_email=settings.SUPPORT_EMAIL,
                context=data,
                template="emails/migrate_default_alerts/priority_alert_feedback.txt",
                html_template="emails/migrate_default_alerts/priority_alert_feedback.html",
                type="priority_alert_feedback.notification",
            )
            msg.send_async(data["emails"])

            redis_client.set(REDIS_KEY, organization.id, ex=60 * 60 * 24 * 7)
            alerts_per_org = {}
            batch = []


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production. For
    # the most part, this should only be used for operations where it's safe to run the migration
    # after your code has deployed. So this should not be used for most operations that alter the
    # schema of a table.
    # Here are some things that make sense to mark as dangerous:
    # - Large data migrations. Typically we want these to be run manually by ops so that they can
    #   be monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   have ops run this and not block the deploy. Note that while adding an index is a schema
    #   change, it's completely safe to run the operation after the code has deployed.
    is_dangerous = True

    dependencies = [
        ("sentry", "0666_monitor_incident_default_grouphash"),
    ]

    operations = [
        migrations.RunPython(
            update_default_alert_rule,
            reverse_code=migrations.RunPython.noop,
            hints={"tables": ["sentry_organization", "sentry_project", "sentry_alertrule"]},
        ),
    ]
