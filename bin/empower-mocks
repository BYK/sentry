#!/usr/bin/env python
from sentry.runner import configure

configure()

import re
import subprocess
import sys
from argparse import ArgumentParser
from datetime import datetime, timezone

import click
import requests
from django.conf import settings

from sentry import buffer
from sentry.models.projectkey import ProjectKey
from sentry.utils.mockdata import get_organization
from sentry.utils.mockdata.core import generate_projects

GCP_BUCKET = "empower-mocks-production"

EMPOWER_PROJECT_IDS = {
    "react": 2,
    "flask": 3,
    "ruby": 4,
}

PROJECT_PLATFORM_MAP = {
    "react": "javascript-react",
    "flask": "python-flask",
    "ruby": "ruby",
}


def download_file(url):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            return response.content
        elif response.status_code == 404:
            return None
        else:
            response.raise_for_status()  # This will raise an HTTPError
    except requests.exceptions.RequestException as e:
        raise Exception(f"An error occurred while downloading the file: {str(e)}")


def get_envelopes(project_name):
    project_id = EMPOWER_PROJECT_IDS[project_name]
    res = []
    i = 1
    while True:
        envelope = download_file(f"http://{GCP_BUCKET}.storage.googleapis.com/{project_id}/{i}")
        if envelope is None:
            break
        res.append(envelope)
        i += 1
    return res


# Example of how to send an envelope to the ingest endpoint:

# curl 'http://dev.getsentry.net:8000/api/1/envelope/?sentry_key=c42483a849febd65cfd8dd6df482e68e&sentry_version=7&sentry_client=sentry.javascript.react%2F8.20.0' \
#  -H 'accept: */*' \
#  -H 'accept-language: en-US,en;q=0.9' \
#  -H 'cache-control: no-cache' \
#  -H 'content-type: text/plain;charset=UTF-8' \
#  -H 'origin: https://application-monitoring-react-dot-sales-engineering-sf.appspot.com' \
#  -H 'pragma: no-cache' \
#  -H 'priority: u=1, i' \
#  -H 'referer: https://application-monitoring-react-dot-sales-engineering-sf.appspot.com/' \
#  -H 'sec-ch-ua: "Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"' \
#  -H 'sec-ch-ua-mobile: ?0' \
#  -H 'sec-ch-ua-platform: "macOS"' \
#  -H 'sec-fetch-dest: empty' \
#  -H 'sec-fetch-mode: cors' \
#  -H 'sec-fetch-site: cross-site' \
#  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36' \
#  --data-raw $'{"event_id":"c59350a64a4841fb96697bd832472b19","sent_at":"2024-08-21T19:53:31.548Z","sdk":{"name":"sentry.javascript.react","version":"8.20.0"},"trace":
def send_envelope_into_ingest(envelope, project_id, public_key):

    # TODO these are part of URL path so should be parsed out of the envelope:
    # &sentry_version=7&sentry_client=sentry.javascript.react%2F8.20.0
    subprocess.run(
        [
            "curl",
            "-X",
            "POST",
            f"http://dev.getsentry.net:8000/api/{project_id}/envelope/?sentry_key={public_key}",
            "-H",
            "content-type: text/plain;charset=UTF-8",
            "-d",
            envelope,
        ]
    )
    click.echo("")


def adjust_timestamp_str_iso(time_str, time_difference):
    original_timestamp = datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%S.%fZ").replace(
        tzinfo=timezone.utc
    )
    new_timestamp = original_timestamp + time_difference
    return new_timestamp.strftime("%Y-%m-%dT%H:%M:%S.%f") + "Z"


def adjust_timestamp_str_unix(time_str, time_difference):
    original_timestamp = datetime.fromtimestamp(float(time_str)).replace(tzinfo=timezone.utc)
    new_timestamp = original_timestamp + time_difference
    return f"{new_timestamp.timestamp():.7f}"


# Shift all timestamps by equal amount so that the latest timestamp found becomes `base_time`
#
# sample timestamps:
# "start_timestamp":"2024-08-21T20:28:13.449378Z"
# "started":"2024-08-21T20:28:00.000000Z"
# "sent_at":"2024-08-21T20:28:13.468774Z"
# "timestamp":"2024-08-21T20:28:13.460543Z"
# "timestamp":1724272105.1860375
#
# NOTE: this can potentially mess up JSON in breadcrumbs, HTTP response bodies, etc.
# but we don't care if that happens as this is demo data and those values can be anything.
# What's potentially undesirable is if extraneous timestamps happens to the latest timestamp
# that's why we try to match keys to reduce the chance of that happening.
def adjust_all_timestamps(input_string, base_time=None):
    base_time = base_time or datetime.now(timezone.utc)
    iso_8601_re = (
        rb"(?<=(?:started|sent_at|mestamp)\":\")\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3,9}Z(?=\")"
    )
    unix_fract_re = rb"(?<=(?:started|sent_at|mestamp)\":)\d{10}\.\d{3,9}"

    datetime_objects = [
        datetime.strptime(ts.decode("utf-8"), "%Y-%m-%dT%H:%M:%S.%fZ").replace(tzinfo=timezone.utc)
        for ts in re.findall(iso_8601_re, input_string)
    ] + [
        datetime.fromtimestamp(float(ts.decode("utf-8"))).replace(tzinfo=timezone.utc)
        for ts in re.findall(unix_fract_re, input_string)
    ]
    if not datetime_objects:
        click.echo(f"[WARNING] No timestamps found in input string: {input_string}")
        return input_string
    latest_timestamp = max(datetime_objects)
    time_difference = base_time - latest_timestamp
    return re.sub(
        iso_8601_re,
        lambda t: adjust_timestamp_str_iso(t.group(0).decode("utf-8"), time_difference).encode(
            "utf-8"
        ),
        re.sub(
            unix_fract_re,
            lambda t: adjust_timestamp_str_unix(t.group(0).decode("utf-8"), time_difference).encode(
                "utf-8"
            ),
            input_string,
        ),
    )


def extract_release_from_envelopes(envelopes):
    all_envelopes = "".join(envelopes)
    release_re = rb'"release":"(.*?)"'
    search_res = re.search(release_re, all_envelopes)
    if search_res:
        return search_res.group(1)  # first match
    else:
        click.echo(f"[WARNING] No release version found in envelopes for project '${project_name}'")


if __name__ == "__main__":
    try:
        settings.CELERY_ALWAYS_EAGER = True

        parser = ArgumentParser(description="Load latest mock data from empower")
        parser.add_argument(
            "-p",
            "--projects",
            default=["react", "flask"],
            nargs="+",
            help="List of empower projects",
        )
        options = parser.parse_args()

        ingest_running = (
            subprocess.run(
                ["pgrep", "-fl", "sentry run consumer ingest-events"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            ).returncode
            == 0
        )
        if not ingest_running:
            click.echo(
                "Ingest is required for empower-mocks but is not running. Please follow https://develop.sentry.dev/development/environment/#ingestion-pipeline-relay-aka-sending-events-to-your-dev-environment"
            )
            sys.exit(1)

        # owner = get_superuser()
        # user = create_user()
        organization = get_organization()
        # create_owner(organization, owner)
        # member = create_member(organization, user, role=roles.get_default().id)
        project_map = generate_projects(
            organization, tuple([("Empower Plant", tuple(p for p in options.projects))])
        )

        for project_name in options.projects:
            envelopes = get_envelopes(project_name)
            project = project_map[project_name]
            project.platform = PROJECT_PLATFORM_MAP[project_name]
            project.save()

            dev_project_id = project.id
            dev_project_public_key = ProjectKey.get_default(project)

            for envelope in envelopes:
                send_envelope_into_ingest(
                    adjust_all_timestamps(envelope), dev_project_id, dev_project_public_key
                )

        click.echo("    > Done sending envelopes. Waiting for processing to finish")

        if hasattr(buffer, "process_pending"):
            click.echo("    > Processing pending buffers")
            buffer.process_pending()

        click.echo("    > Processing complete")

    except Exception:
        # Avoid reporting any issues recursively back into Sentry
        import sys
        import traceback

        traceback.print_exc()
        sys.exit(1)
