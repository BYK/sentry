#!/usr/bin/env python
from sentry.runner import configure
from sentry.utils.mockdata.core import generate_projects

configure()

import re
import subprocess
import sys
from argparse import ArgumentParser
from datetime import datetime, timezone

import click
import requests
from django.conf import settings

from sentry import buffer
from sentry.models.projectkey import ProjectKey
from sentry.utils.mockdata import get_organization

GCP_BUCKET = "empower-mocks-production"

EMPOWER_PROJECT_IDS = {
    "react": 2,
    "flask": 3,
    "ruby": 4,
}


def download_file(url):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            return response.content
        elif response.status_code == 404:
            return None
        else:
            response.raise_for_status()  # This will raise an HTTPError
    except requests.exceptions.RequestException as e:
        raise Exception(f"An error occurred while downloading the file: {str(e)}")


def get_envelopes(project_name):
    project_id = EMPOWER_PROJECT_IDS[project_name]
    res = []
    i = 1
    while True:
        envelope = download_file(f"https://${GCP_BUCKET}.storage.googleapis.com/${project_id}/${i}")
        if envelope is None:
            break
        res.append(envelope)
        i += 1
    return res


# Example of how to send an envelope to the ingest endpoint:

# curl 'http://dev.getsentry.net:8000/api/1/envelope/?sentry_key=c42483a849febd65cfd8dd6df482e68e&sentry_version=7&sentry_client=sentry.javascript.react%2F8.20.0' \
#  -H 'accept: */*' \
#  -H 'accept-language: en-US,en;q=0.9' \
#  -H 'cache-control: no-cache' \
#  -H 'content-type: text/plain;charset=UTF-8' \
#  -H 'origin: https://application-monitoring-react-dot-sales-engineering-sf.appspot.com' \
#  -H 'pragma: no-cache' \
#  -H 'priority: u=1, i' \
#  -H 'referer: https://application-monitoring-react-dot-sales-engineering-sf.appspot.com/' \
#  -H 'sec-ch-ua: "Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"' \
#  -H 'sec-ch-ua-mobile: ?0' \
#  -H 'sec-ch-ua-platform: "macOS"' \
#  -H 'sec-fetch-dest: empty' \
#  -H 'sec-fetch-mode: cors' \
#  -H 'sec-fetch-site: cross-site' \
#  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36' \
#  --data-raw $'{"event_id":"c59350a64a4841fb96697bd832472b19","sent_at":"2024-08-21T19:53:31.548Z","sdk":{"name":"sentry.javascript.react","version":"8.20.0"},"trace":
def send_envelope_into_ingest(envelope, project_id, public_key):

    # TODO these are part of URL path so should be parsed out of the envelope:
    # &sentry_version=7&sentry_client=sentry.javascript.react%2F8.20.0
    subprocess.run(
        [
            "curl",
            "-X",
            "POST",
            f"http://dev.getsentry.net:8000/api/${project_id}/envelope/?sentry_key=${public_key}",
            "-H",
            "content-type: text/plain;charset=UTF-8",
            "-d",
            envelope,
        ]
    )


def adjust_timestamp(match, time_difference):
    original_timestamp = datetime.strptime(match.group(0), "%Y-%m-%dT%H:%M:%S.%fZ").replace(
        tzinfo=timezone.utc
    )
    new_timestamp = original_timestamp + time_difference
    return new_timestamp.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"


# shift all timestamps by equal amount so that the latest timestamp found becomes `base_time`
def adjust_all_timestamps(input_string, base_time=None):
    base_time = base_time or datetime.now(timezone.utc)
    iso_8601_pattern = r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z"
    timestamps = re.findall(iso_8601_pattern, input_string)
    datetime_objects = [
        datetime.strptime(ts, "%Y-%m-%dT%H:%M:%S.%fZ").replace(tzinfo=timezone.utc)
        for ts in timestamps
    ]
    latest_timestamp = max(datetime_objects)
    time_difference = base_time - latest_timestamp
    return re.sub(iso_8601_pattern, lambda t: adjust_timestamp(t, time_difference), input_string)


def extract_release_from_envelopes(envelopes):
    all_envelopes = "".join(envelopes)
    release_re = r'"release":"(.*?)"'
    search_res = re.search(release_re, all_envelopes)
    if search_res:
        return search_res.group(1)  # first match
    else:
        click.echo(f"[WARNING] No release version found in envelopes for project '${project_name}'")


if __name__ == "__main__":
    try:
        settings.CELERY_ALWAYS_EAGER = True

        parser = ArgumentParser(description="Load latest mock data from empower")
        parser.add_argument("-p", "--projects", nargs="+", help="List of empower projects")
        parser.add_argument(
            "-s",
            "--stream",
            default=False,
            action="store_true",
            help="Continuously send new events",
        )
        parser.add_argument(
            "--empower-only",
            default=False,
            action="store_true",
            help="Don't run `load-mocks`, just empower-mocks",
        )
        parser.add_option("--events", default=1, type=int, help="number of events to generate")
        parser.add_option(
            "--skip-default-setup",
            default=False,
            action="store_true",
            help="Skips creating the default project, teams and timeseries, useful when only loading specific transactions",
        )
        parser.add_option(
            "--extra-events",
            default=False,
            action="store_true",
            help="add multiple events for each error group",
        )
        parser.add_option(
            "--load-trends",
            default=False,
            action="store_true",
            help="load multiple transactions for each id to show trends",
        )
        parser.add_option(
            "--load-performance-issues",
            default=False,
            action="store_true",
            help="load transactions with performance issues, still needs options/flags on for issues to appear.",
        )
        parser.add_option(
            "--slow",
            default=False,
            action="store_true",
            help="sleep between each transaction to let clickhouse rest",
        )
        options = parser.parse_args()

        if options.empower_only and (
            options.skip_default_setup
            or options.extra_events
            or options.load_trends
            or options.load_performance_issues
            or options.slow
        ):
            raise ValueError("Cannot use --empower-only with `load-mocks` options")

        if options.stream:
            raise NotImplementedError("Streaming is not yet supported")

        ingest_running = subprocess.run(["ls", "-l"]).returncode == 0
        if not ingest_running:
            click.echo(
                "Ingest is required for empower-mocks but is not running. Please follow https://develop.sentry.dev/development/environment/#ingestion-pipeline-relay-aka-sending-events-to-your-dev-environment"
            )
            sys.exit(1)

        # owner = get_superuser()
        # user = create_user()
        organization = get_organization()
        # create_owner(organization, owner)
        # member = create_member(organization, user, role=roles.get_default().id)
        project_map = generate_projects(
            organization, (("Empower Plant", tuple(p for p in options.projects)))
        )

        for project_name in options.projects:
            envelopes = get_envelopes(project_name)
            project = project_map[project_name]

            dev_project_id = project.id
            dev_project_public_key = ProjectKey.get_default(project)

            for envelope in envelopes:
                send_envelope_into_ingest(
                    adjust_all_timestamps(envelope), dev_project_id, dev_project_public_key
                )

        click.echo("    > Done sending envelopes. Waiting for processing to finish")

        if hasattr(buffer, "process_pending"):
            click.echo("    > Processing pending buffers")
            buffer.process_pending()

        click.echo("    > Processing complete")

    except Exception:
        # Avoid reporting any issues recursively back into Sentry
        import sys
        import traceback

        traceback.print_exc()
        sys.exit(1)
